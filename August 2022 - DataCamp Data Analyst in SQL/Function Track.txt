SQL Functions Learnt

SELECT, use to select attributes you want from a df

SELECT x AS y, use to rename fields in query result

FROM, use to select the dataframe you want to select attributes from

SELECT DISTINCT x, use to select only unique values from selection

COUNT(), use to count number of rows of selected (value)

WHERE, use to specify conditions on a selection

AND, use to add conditions

OR, use to add an alternate condition

x BETWEEN, numerical selection conditon based on two values in attribute

WHERE IN, use to streamline selections to anything in an array

IS NULL, to query for missing data

NOT, to query the opposite of a statement

LIKE 'X%', used in a WHERE clause to search for a pattern
	   'X%' % wildcard will match zero, one, or many characters in text
	   'X_' _ wildcard will match a single character

	e.g. LIKE '_r%' will give rows where the second letter ='r'
		  '%r_' will give records where the second to last letter = r

Variable Types, (can be viewed in database 'schemas'):
VARCHAR - variable character (common for strings)

INT	- intergers

NUMERIC, DATE etc...

CREATE VIEW x AS, assigns subsequent query to 'x' so that the 
		  selection can be made in shorthand in the future

Aggregate Functions
AVG(), SUM(), MIN(), MAX(), COUNT()

ROUND(x, decimalplaces) , round to specified decimal (leave blank for no dec)

GROUP BY

ORDER BY ... ASC/DESC

HAVING, use to filter grouped records

Order of execution:
FROM, WHERE, GROUP BY, HAVING, SELECT, ORDER BY, LIMIT

INNER JOIN
ON xxx.yyy = xxx.yyy, or USING(yyy), (for when key field is named the same)
e.g.
-- Select fields with aliases
SELECT c.code AS country_code, name, year, inflation_rate
FROM countries AS c
-- Join to economies (alias e)
INNER JOIN economies AS e
-- Match on code field using table aliases
ON c.code = e.code

LEFT JOIN x, joins table x as the right to FROM y
RIGHT

FULL JOIN

CROSS JOIN (do not need ON or USING), use to create output of every possible combination of values

<>, operator means 'does not equal'

self joins, used to compare parts of the same table
eg. 
FROM x AS x1
INNER JOIN x AS x2
ON x1.key = x2.key
	AND x1.key <> x2.key; <-- This removes matching rows with themselves

-- Set Theory --

UNION, set operator that merges two tables excluding duplicates

UNION ALL, merges two tables including duplicates

e.g.
SELECT *
FROM left_table
UNION
SELECT *
FROM right_table

eg2.
SELECT p.country_code, p.year
FROM populations AS p
UNION
SELECT e.code, e.year
FROM economies AS e
ORDER BY country_code , year;

INTERSECT, set operator that only returns values present in both tables

eg.1
-- Return all cities with the same name as a country
SELECT name
FROM cities
INTERSECT
SELECT name
FROM countries;

EXCEPT, set operator that returns unique values from the left table

e.g.
-- Return all cities that do not have the same name as a country
SELECT name
FROM cities
EXCEPT
SELECT  name
FROM countries
ORDER BY name;

SUBQUERIES: can occur in WHERE, SELECT and FROM clauses

e.g.
-- Select relevant fields from cities table
SELECT name, country_code, urbanarea_pop
FROM cities
-- Filter using a subquery on the countries table
WHERE name IN
    (SELECT capital
    FROM countries)
ORDER BY urbanarea_pop DESC;

LEFT JOIN & SUBQUERY FOR SAME TASK:

-- Find top nine countries with the most cities
SELECT countries.name AS country, COUNT(*) AS cities_num
FROM countries
LEFT JOIN cities
ON countries.code = cities.country_code
GROUP BY country
-- Order by count of cities as cities_num
ORDER BY cities_num DESC, country
LIMIT 9;


SELECT countries.name AS country,
-- Subquery that provides the count of cities 
  (SELECT COUNT(country_code)
  FROM cities
  WHERE country_code=code) AS cities_num
FROM countries
ORDER BY cities_num DESC, country
LIMIT 9;

SUBQUERY INSIDE FROM 

SELECT DISTINCT monarchs.continent, sub.most_recent
FROM monarchs,
	(SELECT
	continent,
	MAX(indep_year) AS most_recent
	FROM states
	GROUP BY continent) AS sub
WHERE monarchs.continent = sub.continent
ORDER BY continent;